MVR API
MVR/MTR device allows remote operation over http protocol. A remote computer can invoke http call to MVR's IP address that is shown on the Information screen. MVR/MTR can be connected to network by ethernet cable or WiFi connection.


The API is designed by principles described on REST API Tutorial. MVR device acts as a server, and a remote computer is a client connecting to MVR.


Example of address for http requests: http://192.168.1.50:3333/api/ Note: this example url, you need to replace IP address 192.168.1.50 by real address of your MVR device.


The api part of url is fixed path where MVR listens for commands described here. More query parameters or path segments may be appended to end of this url.

Rules of remote controlling
The API server is disabled by default. To use the API, remote access should be enabled for the MVR/MTR device in the Advanced Settings - Connections - Remote Access. Even when enabled, remote access will be denied if the device is actively used to avoid conflicts with the operator. 


MVR/MTR normally allows direct interaction using touchscreen/keyboard/mouse and shows the result on the built-in screen or an HDMI-connected display.


To avoid collisions with direct usage and remote control, these two are exclusive. MVR allows to be remotely controlled only while it's idle, that means when it is in Start screen. While in active study or settings, MVR screens, MVR will refuse remote control with an error explaining reason.


Similarly, when MVR is actively controlled remotely (the remote access session is started), it will show this information on screen and won't allow direct interaction with it until remote control ends.


Simultaneous access to the device remotely and from the UI can be enabled, with caution, by entering a special non-blocking API access password on the same Remote access settings screen.

Remote-control session
Active session is a state when MVR listens to commands from single remote computer, and rejects possible connections from other computers or direct interaction. This is analogy to log-in to and log-out from a server.


MVR uses random ASCII strings generated by MVR (server) for session identification. When client makes request to MVR, it must send session ID, so that it can be identified as currently active client. Any other client with different session ID will be rejected during active session.


Session ID is generated during begin command, and it is returned to client in X-session header field.
Furhter requests from client must include this session ID. This way it is guaranteed that only one client works remotely with MVR at same time, until end of session.
Client provides session id using http header X-session (same way as it received it in begin command), or as query parameter session.


Optional behavior is that client may send its own generated session id in begin request in X-session header field. Then MVR will work with this session ID instead of generating random one. This may simplify development and testing, and will avoid possible lock-outs of MVR and waiting for session time-out if session is not ended. However, this also results in lower security, since same ID is used for each session. It is recommended to let MVR generate session ID.

Visual state
When MVR is in active remote session, it shows information about this on screen, and LEDs on front panel flash to show its state:


Patient LED flashes slowly

Camera LED flashes when API processes some request

Video LED flash when there is file read or write

Session state
The session has a state. Client which begin the session can control device, for example start recording.

Time-outs
MVR can automatically return to idle state after some time of inactivity. When controlled remotely, and session is not closed by remote computer, MVR automatically closes session after 5 minutes of last http request.


Also, when MVR is operated interactively (for example user enters Settings screen), and user doesn't return to Start screen, MVR returns to Start screen automatically after 2 hours of user inactivity.


This way MVR automatically restores itself to usable state and is ready for remote control.

Breaking session
You may forcibly close MVR's remote session by holding the Patient button on front panel for about 10 seconds. This may help during development and testing.

Authorization
Connection session with MVR has beginning and end.


In the begin command, client sends user authorization (password or username and password for identifying valid user), and receives session ID from server. Subsequent commands identify client by only the session ID, and should not contain Authorization header field.


Client can use password (without username) as configured on MVR in Remote access screen, or client can use username and password of some user as configured on MVR in User accounts screen.


Username and password is sent in standard Authorization http header field in format: Authorization: Basic <base64(<user>:<password>)>


Example for me/letmein: Authorization: Basic YWRtaW46NWY0ZGNjM2I1YWE3NjVkNjFkODMyN2RlYjg4MmNmOTk=


You can leave user empty if needed. Password is sent as result of md5 transform (not as plain text). You can use md5 tool to encrypt password to requested format, or use the encryption at runtime on client computer.


Note: if testing with cUrl tool, use -u <user>:<md5(pass)> option to send Authorization header.

Requests
Http request contains a verb after /api/ part of url, specifying resource or command that is requested.

Result of request
Success or failure of http request is signalled in http response code. In general MVR returns code in range 2xx (most often it's 200) for success. Then code 401 for unauthorized access, 400 for bad request (invalid parameters), and code 500 for unexpected errors.


For failure codes (>=300), the reply body is plain text with human-readable text describing the failure.
For successful reply (http code < 300), returned data are in most cases encoded in JSON format. Actual format is described for particular command. If not mentioned, returned data is empty JSON object {}.
Some commands return directly binary data (not JSON), for example compressed PNG image.

Commands
The following describes all requests/commands that this API offers.


Note: most commands require Authentication header field as explained in Authorization paragraph. These are not repeated here for clarity, but for successful API request these must be included.

Request methods
Http protocol offers various methods. This API uses standard methods GET, POST, PUT, and DELETE, and which is used is described along with command.


Example of complete API request:


POST http://192.168.1.50:3333/api/begin

Returning a single field
Many commands that return complex JSON objects (for example device) allow returning also value of just one field. To do this, send requested field name as another path segment of uri (for example /api/device/deviceTitle). The returned JSON object will be in this format:
{ "value": "Title"}


That is, it will contain single field always named value with value of requested field.



begin
POST /api/begin

Request Header fields:


Authorization

authorization token as described above

X-session

optional session ID generated by client


Optional post data sending information about remote client:


{ 

    "DeviceName": "Samsung S8", // name/model of user's device

    "AppVersion": "MVR-190629", // name/version of client application

    "isUsbConnection": 1 // set to 1 if USB tethering connection is used by remote client

 }


Return:


{

    "study": { ... }, // optional if study is active, in format of study/status

    "patient": { ... }, // optional patient which was specified in study/start

    "activeCamera": 0 // optional index of active camera

}


Return header fields:


X-session: session ID for next requests


This is used to begin a session. When successful reply is returned, MVR device is switched to state that it further listens to requests only with same session ID, until end request or time-out happens after which MVR switches back to idle state.



end
POST /api/end

End MVR remote session. That is, return MVR to idle state, where it allows direct interaction or connection from other clients.



cameras
GET /api/cameras

Get list of all cameras in system.


Return:


{

    "cameras": [

        { ... }, // information about camera 1 as written below

        { ... }, // 2nd camera

        ...

    ]

}

GET /api/cameras/usbCamResolutions

Get list of all resolutions supported by USB camera.


(MVR435)


Return:


[

    { "width": 1920, "height": 1080 },

    { "width": 1280, "height": 720 },

        ...

]

GET /api/cameras/{index}/fps

Get real camera resolution, or 0 if camera is not connected.


(MVR435)


Return:


{

    "value": 29.999

}

GET /api/cameras/<index>

index is camera index, in range from 0 to 1


Get information about camera.


Return:


{

    "index":1, // index of camera

    "label":"Endoscopy",  // camera name as set in settings

    "hasSignal":true,  // true if camera has currently valid signal

    "extendRange":true  // true if camera uses full video signal range (0-255) as opposed to limited (16-234)

// optional if hasSignal is true:

    "width":1920,

    "height":1080,

    "framerate":60, 

}


To get value of one field:

GET /api/cameras/<index>/<field>


device
GET /api/device

Get basic information about MVR device. This command works without any authorization (password or session id), as it is intended for discovery of MVR devices on network, so it should work without knowing authentication details.


It returns basic information about device as configured in Settings on Device screen.


Return:


{

    "hospitalName": "Hospital",

    "departmentName": "Department",

    "locationName": "Location",

    "deviceTitle": "Title",

    "hasInternalDisplay": true,

    "hasInternalStorage": true,

    "firmwareVersion": "SYS=200123",

    "serialNumber": "abc01234",

    "isLiteModel": false,

    "appVersion": 200903

}


To get value of one field:

GET /api/device/<field>

GET /api/device/net/[<adapter>]/[<field>]

Get information about network adapter. adapter is one of lan or wifi. field is optional individual field of result.


Return:


{

    "ip": "192.168.1.108", // ip address of connected adapter; null if not connected

    "mac": "01:23:45:67:89:ab", // mac address of adapter

    "ssid": "wifi-name" // connected access point of wifi adapter (not set for lan)

}



input
PUT /api/input/key/<code>

Post key input to currently active Activity or Dialog.
This command works also without active session, and needs standard authorization.
The code is numeric value of standard Android key codes.


Some useful codes:


Key

value

Space

32

A - Z

29 - 54

0 - 9

7 - 16

Back

4

Del

67

Enter

66

Delete

67

Escape

111

Up

19

Down

20

Left

21

Right

22

Previous

260

Next

261

Play/pause

85

Stop

86

Play

126

Pause

127

Record

130

Camera (snapshot)

27

Zoom in

168

Zoom out

169



settings
Settings is a collection of fields permanently saved on device. Settings are normally configured on device, but can be read/written also using the API.
MVR doesn't store setting fields which have default value (typically null or 0), so if some defined field is not returned, this means that it has default value.
Field types can be eigher string, number or json object. Boolean values are expressed by integer 0 (=false) or 1 (=true).

GET /api/settings

Get defined settings, and their values in one json object.


Return:


{

    "video_codec": "h264",

    ...

}

GET /api/settings/<field>

Get value of one field of settings.


Return:


{

    "value": <value>

}


If field with given name is not defined or has default value, empty json object {} is returned.

POST /api/settings

POST-data: json object with new settings


Replaces all settings to defined values, unset fields are removed (reset to default).

PUT /api/settings

POST-data: json object with fields to set


Change only fields from posted json object to given values.

Supported settings fields

Following is list of configurable setting fields and their types.


audio_recording // Boolean

image_format // String jpg | png

video_codec // String h264 | hevc

patient_data // String null | human | animal

hdmi1_name, hdmi2_name // String camera name

quality_super // Boolean

freeze_on_capture // Int seconds 1..10

freeze_position // Int 0..5 corner; 0=off, 5=full screen

stamp // Int 0..4

video_time_limit // Int seconds 0..600

time_lapse_speed // Int time multiplier (e.g. 60 = 1min->1sec)

video_pip // Int 0..4 corner; 0=off

video_pip_size // Int percent size of screen

pause_function // Boolean

parallel_recording // Boolean

hdmi_1_extend_range // Boolean

hdmi_2_extend_range // Boolean

usb_storage // 0, 720, 1080, *2160

internal_storage // 0, 720, 1080, 2160

network_storage // 0, 720, 1080, 2160

display_brightness // Int in %, 0 is special value meaning 100%

display_rotation // Boolean

mouse_speed // -7 .. 7

network_label // String

network_host // String

network_path // String

network_user // String

network_pass // String

network_domain // String

network_video_limit // Int; 0 = only images

web_config // Boolean

web_config_pass // String

hospital_name // String

department_name // String

location_name // String

device_title // String

worklist_server // json { ip: String, port: Int, server_title: String, device_title: String, modality: String, charset: String, match_scheduled_aet: Boolean, match_scheduled_date: String }

pacs_server // json { ip: String, port: Int, server_title: String, device_title: String, modality: String, charset: String, disable_video_upload: Boolean }

web_config_message // String

lan_static_ip // json { ip: String, mask: String, gateway: String, dns: String}

ntp_server // String

export_to_pacs // Boolean

pacs_auto_send // Boolean

pacs_delete_after_send // Boolean

internal_storage_watch_free_space // Boolean

internal_storage_auto_delete_old // Boolean

disable_usb // Boolean

bluetooth // Boolean

bluetooth_serial_mac // String

wifi // Boolean

print_copies_number // Int

auto_report // Int; 0=disabled, 1=print, 2=pdf

report_page_layout // Int

report_page_size // String

report_footer_text // String

language // String

audio_volume // Int 0..100 inverted; 0 = maximal volume

samba_server_enabled // Boolean

samba_server_password // String

samba_server_workgroup // String

paid_features // json

stamp_filenames // Boolean

user_accounts_enabled // Boolean

users // jsonarray [ json { name: String, password: String, create_time: Long }, ... ]

rs232_baudrate // Int

rs232_parity // String

rs232_stop_bits // Int

remote_app_local_storage // Boolean

inactivity_timer // Int (minutes)

password_renew_days // Int



ping
GET /api/ping

A keep-alive command that informs MVR that session is active. If needed, client can call it periodically to check connection with MVR and avoid to time-out session. It normally checks session ID, so ensures that session is healthy and ready for other commands.



storages
GET /api/storages

Get list of all storages currently available.


Return:


{

    "storages": [

        { ... }, // information about one storage as written below

        { ... }, // 2nd storage

        ...

    ]

}

GET /api/storages/<type>

type is storage type, one of INTERNAL, USB or NETWORK


Get information about storage.


Return:


{

    "type": "USB",  // type of storage

    "freeSpace": 25111494656, 

    "totalSpace": 30979145728,

    "nextStudyIndex": 67,   // index of next study

    "label": "KINGSTON" // label of storage device

}


To get value of one field:

GET /api/storages/<type>/<field>


storage
PUT /api/storage/eject/USB

Eject USB storage. After calling this, USB storage will be removed from list of storages, and user can safely unplug the USB storage.


To return USB storage back, user must physically unplug it from MVR and plug it back again.



folders
This command allows listing files on storage, or create new folders.

GET /api/folders/<type>/<path>

Get list of a files and folders in a folder.
type is storage type, see supported storage types under storages command.
path is sub-path in storage, it may be empty for storage root.


Return:


{

    "list":[

        // information about one file or folder as written below

        {

            "name": "image.jpg",  // file name

            "isDir": false,  // true for folder, false for file

            "lastModified": 1553445488000,  // last-modify time in unix file format (milliseconds)

            "size": 576866304,  // size of file (only present for files)

            "pacsStatus": 2 // optional status of file PACS upload result; may be: 0=scheduled, 1=uploaded, 2=upload error

        },

        { ... }, // 2nd file

        ...

    ]

}

PUT /api/folders/<type>/<path>

Create a new folder.


Return:
Success is identified by successful http response code.



files
This command allows to:


get content of a file

delete file

rename file

create new file

GET /api/files/<type>/<path>

Get content of a file.
type is storage type, see supported storage types under storages command.
path is sub-path in storage.


Return:
Raw data stream of file.
This command is exception from others in that it returns binary file stream instead of json object.

PUT /api/files/<type>/<path>

POST-data: { "name": "<new name>" }


Rename file or folder to new name.


Return:
Success is identified by successful http response code.

PUT /api/files/<type>/<path>

POST-data: { "lastModifyTime": time }


Set last-modify time of file.


Return:
Success is identified by successful http response code.

POST /api/files/<type>/<path>

POST-data: binary file stream


Create a new file and write data into it.


Return:
{ "size": <file-size> }

DELETE /api/files/<type>/<path>

Delete a file or folder.



file_info
GET /api/file_info/<type>/<path>

Get information about a file or folder.


Return:


{

    "isDir": false,  // true for folder, false for file

    "lastModified": 1553445488000,  // last-modify time in unix file format (milliseconds)

    "size": 576866304  // size of file (not present for folders)

}



system
PUT /api/system/reboot

Reboot device.

PUT /api/system/format/<type>

Format storage. type may be USB or INTERNAL.

PUT /api/system/reset_settings

Reset settings to defaults.

PUT /api/system/factory_reset

Reset entire device to factory settings.

POST /api/system/firmware

Upload firmware update file (*.upd) onto device, and reboot to update.
Content of file is being sent as binary stream.

GET /api/system/hostname

Get device host name.


Return:


{

    "value": "iMave-012345678"

}

PUT /api/system/hostname/<host-name>

Set device host name.



audio
GET /api/audio

Get information about connected audio devices.


Return:


{

    "devices": ["WIRED", ...] // one of BLUETOOTH / WIRED / USB

}

GET /api/audio/monitor

Monitor volume of connected audio device. Returns permanently connected stream similar as described in notify command.
Possible response objects:


{"device": USB}  = connected audio device


{ "monitor": {"primary":279,"secondary":303} }  = visualization of audio monitoring, in range 0-1000



notify
GET /api/notify

Obtain notifications about run-time changes of resources (storages, cameras, study, etc).
This creates permanent connection to device, and MVR returns notification responses as individual json objects.


The format of response is stream in http Transfer-encoding: chunked format. That means that each json object is being sent in separate chunk, which may help client to find boundaries of json objects that MVR returns. Chunked http encoding is explained here.


Http response normally also contains the header field Transfer-encoding: chunked. If your http library automatically parses chunked encoding, you can disable MVR to set this header by adding X-no-encoding: true in http request, then your client code will receive raw stream and can process chunked encoding itself (read chunk size, read json content, process json, wait for next chunk and repeat).


Example of notification stream:


23

{"storages":[{"type":"INTERNAL"}]}


2b

{"cameras":[{"index":0,"hasSignal":false}]}


The notify command doesn't return, and it sends notifications in loop until client closes the http connection, or remote session is ended. Client should not set read-time-out in the http request, rather it should wait for reponse forever.


Periodically MVR returns empty json object {} as a mechanism to check if client's connection is still alive. If this keep-alive empty object fails to be sent to client, MVR closes the notify request.

Types of notifications

The notify command monitors resources on MVR that can change, and reports these changes immediately to connected client.


Here are described types of json objects that can be returned. Each notification object contains zero or more objects identified by json name.


{ "storages": [ {...}, ... ] }
List of storages available when notify command starts. This object is sent just once at beginnig. Value is json array same as returned for storages command.
Further, changes on storages are reported in add/remove storage notifications described below.


{ "storageAdd": {...} }
Notification that single storage was added. The value is one storage json object as described in storages command.


{ "storageRemove": {...} }
Notification that single storage was removed. Value is same as for storage_add notification.


{ "cameras": [ {...}, ... ] }
List of cameras available when notify command starts. This object is sent just once at beginnig. Value is json array same as returned for cameras command.
Further, changes of a camera is reported in camera_change.


{ "cameraChange": {...} }
Notification that signal of single cameras has changed (e.g. hdmi plugged/unplugged, or resolution changed). The value is one camera json object as described in cameras command.


{"networkConnected": true}
Notification about changes in device network connectivity. Although using API requires network connection, so value will be usually true, but the notification is also sent when after changes on other network adapter (LAN or WiFi).


{

  "keyEvent":{

    "action":1, // action, 1=down, 0=up

    "keyCode":35, // key code

    "repeat":2, // optional repeat count

    "meta":65 // optional meta flags (ctrl/alt/shift)

  }

}


Key event passed from MVR device to remote app. Key events may come from device's device hardware keys, from foot pedals, or from attached USB keyboard.
The object contains fields from Android's KeyEvent, you can find key codes and meta flags in that documentation.

Following are types of notifications related to active study

These are sent during active study until the study is finished or entire session ended.
All keys of notifications related to active study start with "study".


{ "studyEvent": "rendererInitialized" }
Camera renderer is initialized, and study is ready for capturing and creating preview.


{ "studyChanged": <study status> }
Study has changed. Value contains complete study state in same format as for study/status command.


{ "studyEvent": "closed" }
Study is being closed.


{ "studyRecordTime": 3000 }
While recording is active, this is current time of recorded file. This value is updated every second.


{ "studyRecordState": "STOPPED" }
State of video recording changed. Possible values are: STOPPED, RUNNING, PAUSED


{ "studyParallelRecordingActive": false }
State of parallel recording (boolean value).


{ 

    "studyRecorderStarted": { 

        "file": { "storage":"INTERNAL", "filePath":"CASE0071\/V0001.mp4" }, 

        "studyCounters": { "nextFileSequence":2, "lastImageSnapshotSequence":0, "lastVideoRecordSequence":1 }

    } 

}


Video recording was started on one storage in given path. Notify event contains file identifier where video is recorded, and new variable state of study.


{ "studyRecorderStopped": "INTERNAL" }
Recording was stopped on one storage. Value represents type of the storage, one of INTERNAL, USB or NETWORK.


{ "studyCameraActivated": 0 } Active camera has changed. Value is index of currently active camera, or -1 for no active camera.


{"studyCameraChanged": 0} Signal of one camera has changed (e.g. hdmi cable attached or detached). Parameter is index of changed camera.


{   "studySnapshotCaptureStarted": {

        "studyCounters": {"nextFileSequence": 4, "lastImageSnapshotSequence": 3, "lastVideoRecordSequence": 2}

    }

}


Image capture is started. Value is variable state of study. Only one image may be captured at a time.


{

    "studySnapshotCaptureFinished": {

        "file": {"storage":"INTERNAL", "filePath":"CASE0075\/I0003.jpg"}

    }

}


Image capture was saved to file, and study is ready for next image capture.


{"studyThumbnail": "_9j_...2Q=="}
Thumbnail was captured. Value is binary JPEG image stream encoded in url-safe base64 format. Thumbnail can be explicitly asked by study/thumbnail, or it's sent also after image was captured.


{"pacsFileStatus": {"file": {"storage":"INTERNAL", "filePath":"CASE0001\/I0001.mp4"}, "value": 0}}
PACS status of a file has changed. Status number is same number as field pacsStatus in command GET /api/folders


{ "pacsStatus": { "uploading": true, // true if PACS is currently uploading a file "lastError": "..." // optional last error encountered during uploading } }
Current state of PACS uploader.


{   "studyStreamWatchersChanged": [

        {"name":"<admin>","ip":"192.168.1.40"},

        ...

    ]

}


List of stream watchers was changed.



study
Active study is a state of MVR when it initializes camera(s), and can perform recording and image captures.

PUT /api/study/start

Start new study. Body (http-post data) is a json object with these optional parameters:


{

    "path": "CASE0002", // if specified, study will be appended into specified folder on all enabled storages

    "patient": { // patient information

        "AccessionNumber": "03683", // String dicom (8,50)

        "WlStudyDate": "20190712", // String dicom (8,20)

        "WlStudyTime": "143339", // String dicom (8,30)

        "ReferringPhysician": "A^B^C", // String dicom (8,90)

        "PerformingPhysician": "A^B^C", // String dicom (8,1050)

        "RequestingPhysician": "A^B^C", // String dicom (32,1032)

        "ReferencedSopClassUid": "1.2.3.4", // String dicom (8,1110)/(8,1150)

        "ReferencedSopInstanceUid": "1.2.3.4", // String dicom (8,1110)/(8,1155)

        "OtherPatientIds": "1.2.3.4", // String dicom (10,1000)

        "PatientLastName": "Melanie", // String

        "PatientMiddleName": "Daysy", // String

        "PatientFirstName": "Christen", // String

        "PatientID": "TPI381063", // String dicom (10,20)

        "PatientAddress": "", // String dicom (10,1040)

        "MilitaryRank": "", // String dicom (10,1080)

        "LastMenstrualDate": "", // String dicom (10,21d0)

        "MedicalAlerts": "", // String dicom (10,2000)

        "Allergies": "", // String dicom (10,2110)

        "AdditionalPatientHistory": "", // String dicom (10,21b0)

        "PregnancyStatus": 0, // Int dicom (10,21c0)

        "PatientBirthYear": 2017, // Int

        "PatientBirthMonth": 12, // Int

        "PatientBirthDay": 31, // Int

        "PatientGender": "F", // String dicom (10,40)

        "PatientNotes": "", // String dicom (8,1030)

        "StudyDate": 1565021826, // Long

        "StudyInstanceUID": "1.2.826.0.1.3680043.9.7572.5236", // String dicom (20,D)

        "RequestedProcedureID": "RP4250", // String dicom (40,1001)

        "RequestedProcedureDescription": "", // String dicom (30,1060)

        "AdmissionID": "", // String dicom (38,10)

        "SpecialNeeds": "", // String dicom (38,50)

        "StudyDate": 1565021467566

        "ScheduledModality": "", // String dicom (40,100)/(8,60)

        "ScheduledStationAET": "", // String dicom (40,100)/(40,1)

        "ScheduledProcedureStartDate": "", // String dicom (40,100)/(40,2)

        "ScheduledProcedureStartTime": "", // String dicom (40,100)/(40,3)

        "ScheduledProcedureEndDate": "", // String dicom (40,100)/(40,4)

        "ScheduledProcedureEndTime": "", // String dicom (40,100)/(40,5)

        "ScheduledPhysician": "", // String dicom (40,100)/(40,6)

        "ScheduledProcedureStepDescription": "", // String dicom (40,100)/(40,7)

        "Dicom_40_275__8_100": "", // String dicom (40,100)/(40,8)/(8,100)

        "Dicom_40_275__8_102": "", // String dicom (40,100)/(40,8)/(8,102)

        "Dicom_40_275__8_103": "", // String dicom (40,100)/(40,8)/(8,103)

        "Dicom_40_275__8_104": "", // String dicom (40,100)/(40,8)/(8,104)

        "ScheduledProcedureStepID": "", // String dicom (40,100)/(40,9)

        "ScheduledLocation": "", // String dicom (40,100)/(40,11)

        "ScheduledProcedureStepStatus": "", // String dicom (40,100)/(40,20)

        "ScheduledProcedureComments": "", // String dicom (40,400)

        "RequestedProcedureID": "", // String dicom (40,1001)

        "RequestedProcedurePriority": "", // String dicom (40,1003)

        "RequestedProcedureComments": "", // String dicom (40,1400)

        "AnatomicRegion": "{}", // json { display: String, code: String } dicom (8,2218)

        "BodyPartExamined": "", // String dicom (18,15)

        "AnatomicModifier1": "{}", // json { display: String, code: String } dicom (8,2220)

        "AnatomicModifier2": "{}", // json { display: String, code: String } dicom (8,2220)

        "Laterality": "", // String dicom (20, 60)

    }

}


Following commands work only if study is started.

GET /api/study/status

Get status on current study.


Return:


{

    "storages":["INTERNAL"], // storages to which recording will happen

    "path":"CASE0072", // path for study on storages

    "creationDate":1556994371677, // date when study was started

    // following is variable study state:    

    "isReadyForRecording":true,

    "recordState"":"STOPPED",

    "canCaptureSnapshot":true,

    "studyCounters": { // file counters related to study

        "nextFileSequence":1,"lastImageSnapshotSequence":0,"lastVideoRecordSequence":0

    }

}


To get value of one field:

GET /api/study/status/<field>

PUT /api/study/finish

Finish current study.

PUT /api/study/snapshot

Capture snapshot (image) to all enabled storages.
Optional url query parameter: ?notes=<notes> to put notes into image.

PUT /api/study/snapshot/{png|jpg}

Same as study/snapshot, but also return captured image stream as PNG or JPG file.
The format setting controls only type of image returned over API, and doesn't affect how snapshot is actually saved on MVR's enabled storages.
Return: image data stream

PUT /api/study/record/start

Start video recording.
Optional url query parameter: ?notes=<notes> to put notes into recorded video.

PUT /api/study/record/stop

Stop video recording.

PUT /api/study/record/pause

Pause video recording.

PUT /api/study/record/resume

Resume video recording.

GET /api/study/thumbnail

Create thumbnail (small image) of current camera output. Result is delivered asynchronously in notification.

GET /api/study/video

Get video stream preview. The stream is continuous until client doesn't close connection, or study is finished, or some error is encountered.
Video stream is in fragmented-mp4 format. It doesn't contain audio.

GET /api/study/audio

Get audio stream. That means recording of currently connected audio input device. Its lifetime is same as video stream.
Audio stream is in AAC/ADTS format.

DELETE /api/study/watcher/<id>

Remove specified stream watcher. The <id> is identifier of watcher, which is url-encoded json object in same format as in notification of type studyStreamWatchersChanged.

PUT /api/study/camera/swap

Swap camera sources. Cameras are swapped only when both are initialized, and there is no active recording (except of paraller recording, which allows camera swap).



stream
Obtain audio or video stream.
The stream works either in active study initiated by API, or in manually created study directly on device.

Stream authorization:

Unlike the study API command, this command doesn't use authorization by session ID, because there may not be any API session started. So authorization is performed by username/password, same as for begin command.
Additionally, streaming requires a PIN, which is string unique to each active study. Stream watchers need to obtain the pin before attempting to open video or audio stream. The pin is obtained by stream/authorize command.

GET /api/stream/authorize[?pin=<pin>&timeout=<milliseconds>]

Ask authorization for using streaming on active study. This call may be long-running, because it may display visual UI, and wait for user to confirm it.
Optional parameters:


pin = previously known pin, when set, and it's correct, it may skip UI dialog and directly return successful reply

timeout = time how long to wait for reply (default is 1 minute)

GET /api/stream/video?pin=<pin>

Get video stream preview. See study/video for details.

GET /api/stream/audio?pin=<pin>

Get audio stream. See study/audio for details.

GET /api/stream/status

Get status of video streaming for this client. Actually it also returns last reason that caused streaming to stop.


Return:


{ 

    "value":"REMOVED", // status of streaming

    "no_signal": true  // optional value indicating that there is no camera signal

} 


Possible values:


NO = no streaming is active

ACTIVE = this client is receiving video stream

NO_STUDY = study is not started

INPUT_CHANGED = input changed (camera disconnected or swapped)

ERROR = input error occured

REMOVED = this client was removed by device operator



time
GET /api/time

Get current system time as milliseconds in Unix time format.


Return:


{

    "value": <value>

}

PUT /api/time/set/<value>

Set current system time, value is milliseconds in Unix time format.

GET /api/time/zone

Get ID of system time zone. The ID is one of Java TimeZone class ids (getAvailableIDs).


Return:


{

    "value": <value>

}

PUT /api/time/zone/<value>

Set current system time zone. The value is url-encoded.



logs
GET /api/logs

Get all logs.


Return:


{

    "value":[

        { // single log entry

            "id": 9105, // id of this log entry

            "t": 1581960090769, // time when log was created

            "d": "Settings changed: bluetooth=1", // log text

            "c": "system", // category, one of: settings, archive, study, maintenance, error, system

            "u": "admin @192.168.1.40" // optional info about logged-in user

        },

        ...

    ]

}

DELETE /api/logs/[id]

Delete all logs or one log with specified id.

POST /api/logs

Post data contain one log entry:


{ 

    "d": "Settings changed: bluetooth=1", // log text

    "c": "system" // category, one of: settings, archive, study, maintenance, error, system

 }



pacs
PACS API allows uploading files from MVR to configured PACS server, and offers functions regarding this functionality.
Only files from device's internal storage can be uploaded to a server.
MVR device keeps track of the upload status for files on internal storage. The status may be one of:


scheduled to be sent (or just being sent)

sent successfully

failed to be sent, with saved error message

not tracked


The paths used in API are relative file paths on Internal storage, for example CASE0001/I0001.jpg.

PUT /api/pacs/test

Test PACS server.
Post data contain parameters:


{

    "server": { }, // definition of PACS server, in format described above for "pacs_server" in Supported settings fields

    "timeout": 10000 // optional timeout how long to wait for server reply; if ommited then 10000 is used

}


Return value contains json data of test result:


{

    "transferSyntaxes": { // map of transfer syntaxes supported by the server

        "1.2.840.10008.5.1.4.1.1.77.1.4":["1.2.840.10008.1.2.1","1.2.840.10008.1.2.4.50"],

        ...

    },

    "implementationClassUid": "1.2.40.0.13.1.3", // UID of server implementing the PACS service

    "implementationVersionName":"dcm4che-5.13.2" // name and version of server

}

POST /api/pacs

Post files to PACS server.
The files will be scheduled to be uploaded to PACS server, and this API call returns immediately.
Actual upload will be done later in background, and status of file uploads will be reported over api/notify channel.


Post data:


{ 

    "value": [ // value is array of file paths

        "CASE0001\/V0001.mp4", 

        "CASE0001\/I0001.jpg",

        ... 

    ]

 }


API call returns successful status code if PACS server is running and files are accepted, or failure http code if PACS server doesn't currently run (for example if DICOM export is disabled on device).

PUT /api/pacs/retry

Retry sending of scheduled files to server.

PUT /api/pacs/abort

Abort current transfer, and unscheduled all files scheduled for upload.

PUT /api/pacs/reset

Reset PACS database, that is clear PACS state of all files on device.

PUT /api/pacs/remove

Remove list of files from PACS database, that means to clear PACS state of these files.
Post data:


{ 

    "value": [ // value is array of file paths

        "CASE0001\/V0001.mp4", 

        "CASE0001\/I0001.jpg",

        ... 

    ]

 }

GET /api/pacs/errors

Get list of all files that had error during upload to PACS. The list may be possibly empty.


Example reply:


{ 

    "value": [ // value is array of file objects

        { 

            "path": "CASE0179\/V0001.mp4", // file's path

            "error": "Server does not support ES:H.264" // error message

        },

        ...

    ]

}

GET /api/pacs/count

Get number of files for which device tracks PACS upload status.


Example reply:


{"value":6}

GET /api/pacs/scheduled

Get statistics of all files scheduled to be sent to PACS server.


Example reply:


{

    "v": 1, // number of videos 

    "i": 2, //  '' images  

    "p": 1 // '' PDFs

}

PACS notifications

PACS service sends some notifications over notify channel (see command /api/notify), they are:

pacsFileStatus

{"pacsFileStatus": {"path": "CASE0001\/I0001.jpg", "value":0, "deleteStatus": "FileDeleted" }}


Notification about change of PACS state of single file. The value may be:


0 = scheduled for upload

1 = uploaded successfully

2 = upload error


When value is not present, it means that file was removed from PACS database, and it has no PACS status now.


Optional field deleteStatus can have value:


FileDeleted = the file identified by path was deleted (after being uploaded to PACS server)

FolderDeleted = folder identified by path was deleted (after it became empty when all files were uploaded to PACS server, and deleted)

pacsStatus

{  

    "pacsStatus": {  

        "uploading": true // current upload status of PACS service. true is some file is currently being uploaded. 

    }  

}


Notifies about change in PACS service.



worklist
GET /api/worklist[/notify]?[limit=<l>&][<dicom-tag>=<filter-value>&][server={}&]

Get patients from worklist server.


Response:


{

    "value":[

        { // single patient object

        },

        ...

    ]

}


Returned patient object has same format as specified in study/start API command.


When you use optional command form worklist/notify, then returned data are send as chunked data as specified in api/notify command, and individual patient objects are sent in separate chunks as "patient" objects.
This may be useful when worklist download takes longer time, and calling app wants to display patients as soon as they are downloaded from server (not waiting for entire list to come).

Query parameters:

limit = maximal number of patient objects to return


<dicom-tag> = DICOM tag to filter agains, there may be multiple of these, and this query parameter name is set to hexa-decimal numeric form of dicom tag, for example 00080050 would be parameter to filter by DICOM Accession Number. The filter-value is actual string value of the dicom tag to filter against.


server = optional definition of worklist server, in format described above for "worklist_server" in Supported settings fields.
If omited, the server parameters are taken from Settings from "worklist_server" field.

PUT /api/worklist/test

Test worklist server. Command works in same way as api/pacs/test, except that it tests worklist server and expects "worklist_server" form of server parameter.



Overlays
MVR API offers mechanism to place overlay image on top of video input. Overlays are drawn on preview screen, as well as written into recorded images and videos.


The purpose of overlay is to display additional information on top of image from camera.


It's possible to put custom overlays only when using MVR API (not when interacting with device directly).

Definition of overlay
Overlay is a rectangle placed on screen. It can have background, defined by image (png or jpg), or solid color. It can be placed in one of 9 basic positions on screen (top-left, top, top-right, left, center, right, bottom-left, bottom, bottom-right).


Additionally it can be offset from this position horizontally and vertically, so for example it can be positioned at some distance from screen edge.


By default, overlay is placed within screen bounds, but optional parameter fitToAreaOfInterest allows to place overlay within area of interest (AOI) defined for camera.


The rectange has size normally determined from its background image, but the size may be overriden in horizontal or vertical dimensions, or both. If you override only one dimension, other one will be automatically computed to retain aspect ratio of background image. In case of no or solid-color background, size must be specified.


Sizes and offsets are specified in pixels for reference full-hd resolution (1920x1080). In case of camera signal in different resolutuion (e.g. 4K), orverlay size is automatically resized so that it retains same relative position and size, as if camera signal was in full-hd resolution.


Overlay can show additional information in text format. Multiple texts can be placed in each overlay.

Errors

For possible errors in json definition of overlay, MVR attempts to show failure as overlay with special background with blue X cross, or even error text in the overlay. The reason is that errors in definitions are not silently ignored, but visually shown so that they can be fixed.

Colors
Whenever color is specified in json, it is set as string in form: "#RRGGBB", "#AARRGGBB" or one of the following names: "red", "blue", "green", "black", "white", "gray", "cyan", "magenta", "yellow", "lightgray", "darkgray", "aqua", "fuchsia", "lime", "maroon", "navy", "olive", "purple", "silver", "teal"

Background
Following background types are possible:


No background

Image from png or jpg file stored in local folder on device's storage (iMave folder)

Image uploaded by API command (in png or jpg format)

Solid color, in format described in Colors


Background images can have transparent pixels.

Elements
Following are elements that can be placed into overlays.

Text
Texts are drawn on top of background, within overlay's rectangle.
Each text have position defined same way as the overlay, but it's relative to overlay's rectangle, that is one of 9 possible placements.

Images
Images allow to place another image into overlay. This may be some indicator or other image that can move within overlay.

Lifetime and updating
Overlays can be created, updated and deleted. You can make each API operation on one overlay or on array of overlays, so it's possible to batch operation on multiple overlays in one API call.
Updating of overlay can change certain properties of overlay (those that you specify in json data), and won't touch other fields. Updating of overlay can't create new or delete existing elements of overlay.
If structure of your overlay changes significantly, you have to recreate the overlay and not update it.
If you need to show or hide some elements of overlay, you can create such element as invisible, and later change its visibility.

API
Create overlay

POST /api/study/overlays

POST-data:


{

    "id": 1, // optional identifier of overlay; used to update or remove it

    "position": { // optional position of overlay

        "alignment": "R", // optional alignment, one of TL, T, TR, L, C, R, BL, B, BR (defaults to C)

        "width": 200, "height": 350, // optional size of overlay, in pixels; each dimension may be omited

        "offsetX": -110, "offsetY": 30 // optional offset of overlay (in pixels) from its ideal position defined by alignment

    },

    "fitToAreaOfInterest": true, // optional flag to fit overlay into area of interest

    "backgroundColor": "red", // optional background color, in format described in Colors

    "backgroundLocalFile": "sample.png", // optional file name of image used for background (relative to iMave folder on device)

    "elements": [ // optional array of sub-elemements in overlay

        {

            "id": 1, // optional identifier of element; used to update it

            "type": "text", // type of element one of "text" or "image"

            "position": { // mandatory position of element; format is same as for overlay's position

                "alignment": "B",

                "offsetY": -4

            },

            "size": 16, // optional size of text in pixels (integer of float)

            "color": "green", // optional text color; default is white

            "backgroundColor": "#40000080", // optional background color; default is transparent

            "text": "Fully charged and ready for service", // optional text

            "shadow": 1 // optional shadow; value 0 or 1

        },

        {

            "type": "image",

            "position": {

                "alignment": "L",

                "offsetY": -40

            },

            "visible": true, // optional element visibility, default is true

            "localFile": "arrow.png", // mandatory file name; for format see backgroundLocalFile 

            "pivotX": 0.5, "pivotY": 0.9, // optional pivot, in relative coordinates of image's rectange; pivot is used for image rotation

            "rotation": 75 // optional rotation andgle in degrees

        }

    ]

}


Creates new overlay. If overlay with given id already exists, it is removed first.

Create multiple overlays

POST /api/study/overlays

POST-data:


[

  { 

     // object of overlay 1

  },

  {

     // object of overlay 2

  }, ...

]


Create multiple overlays in one call. The difference from single overlay creation is that data represent JSON array (start with '[' character), and contain array of items to create.
The format of overlay is same as for single overlay creation.



Update overlay

PUT /api/study/overlays/<id>

POST-data:


{

    "backgroundColor": "red",

    "position": {

        "offsetX": -10

    }

}


Update parameters of existing overlay. Overlay is identified by id. POST-data contain json object with overlayâ€™s new fields. Specified fields of overlay will be updated and overlay will be redrawn. You should post only fields that are changing.
Only these fields of element can be updated:


position (individually any of position fields, e.g. only offsetX)

backgroundColor

backgroundLocalFile


Note: to update parameters of individual elements, use following API function.



Update overlay's element

PUT /api/study/overlays/<id>/<element-id>

POST-data:


{

    "color": "green",

    "text": "Oxygen: 27"

}


Update element in existing overlay. Overlay is identified by id and element is identified by element-id. POST-data contain json object with element's new fields.
Only these fields of element can be updated:


text: text, size, color, backgroundColor, visible

image: rotation, visible



Update multiple overlays

PUT /api/study/overlays

POST-data:


[

    {

        "id": 1, // needed identifier of overlay to be updated

        "elements": [ // optional array of elemements to update

            {

                "id": 1, // needed identifier of element to be updated

            }, ...

        ], 

        // other update data of overlay

    }, ...

]


Update multiple overlays, where post data contain json array of items to be updated.



DELETE /api/study/overlays/<id[,id2,id3,...]>

Remove overlay with given id. The last path segment is single id, or list of id's to delete, separated by comma.



RS232 connection
It's possible to conect to MVR device over RS232 USB serial connection. Same API works as for case of Internet connection, with few differences that are explained here.

Protocol
Standard API uses http protocol over TCP/IP line. RS232 uses serial connection over USB cable or Bluetooth serial connection, with following details:


Session ID is not used, each RS232 connection has automatic unique session ID (API user doesn't need to care about this)

Authorization in begin command uses different way to send username/password

Same rules of exclusive access to device exists as with main API, that is beginning and ending session is still necessary

Each command sent to device must be sent on one line, terminated by new-line character (except of when posting binary data as explained below)

Every reply to command is on single line, terminated by '\n' character (except of when sending back binary data as explained below)

Encoding of strings is utf-8

Most GET api commands don't need active session (begin/end): storages, cameras, folders, files, file_info, file_thumbnail, study/status, time, pacs, study/notify

Format of request
<method> <path> [<command-id>] [<optional data>]\n


method is one of standard http methods: GET, POST, PUT, DELETE

path is usual API command path, without the /api/ part

command-id is optional string that MVR return back as part of reply; this is intended for pairing reply with request on client side

optional data are post-data required for some commnands, these data are read to end of line, so may contain additional whitespace characters (except of new-line)


Example:
POST begin 13 { "DeviceName": "Samsung S8", "AppVersion": "MVR-190629" }\n


For most commands client can expect one reply for one request. However, notify kinds of commands work asynchronously, that's where command-id is utilized to know to which command the reply was sent.

Authorization

In the begin command, client sends user authorization (password or username and password for identifying valid user) inside of json object (the optional data).


Example:
POST begin 13 { "user": "admin", "pass": "abc123" }\n

Sending request with binary data

In case of binary data sent as <optional data>, the format is following:
After 3rd word token of command, client must send byte \0, following by string (decimal number) specifying size of following binary data, terminated by single space character. Right after terminating space character follow binary data of specified size. No terminating '\n' is needed after such formatted command.


Sending binary data is rare for commands uploading a file. Most commands use data as JSON string (that implies that JSON data can't contain new-lines).

Format of reply
<json reply>\n[optional data]


The reply is always a string in json format, terminated by new-line character.


The reply contains these fields:


{

    "id": "13", // command-id as sent by client

    "error": "<text>", // optional error text in case that command execution failed

    "reply": "<string data>", // optional data in case that command returns string data

}

Notify commands
The notify (async) commands work also over serial connection. However, because requests and responses don't run over dedicated connection (like http connection works), notify requests can't be terminated by closing connection. For this purpose, rs232 processor adds command to stop notifications for given command id:

CANCEL <id-to-cancel> [<command-id>]

This will stop notification which was started previously with id-to-cancel. This is command like others, so optionally this request can have own command-id.
This also implies that each active notification must use unique command id. Starting new notification comand with command id of already running notification will first cancel previous notification.

File transfer
Download:

Downloaded files are retrieved in chunks of bytes. One file may be sent in one or more chunks. Because files may be large, they're sent in smaller parts (approx 1KB), so that other data can be also transferred while a file is downloaded.


After file download request (GET files/<type>/<path>), 1st reply is normal reply as written above. If file length is known, the reply includes "length": 12345 field.


Following are chunks of file's data until eof is included in the chunk reply.
The reply to file download command is following:


{

    "id": "13", // command-id as sent by client; the id used in file-download request

    "chunk": 123, // size of binary data chunk following the last new-line character after json object

    "eof": true // signal that this is last chunk and end of file; no more data will arrive for this command

}


Downloading of file is cancelable. To cancel file download, send request:

CANCEL <command-id>

This will stop file download for given request id. No more file data will be sent after this.

API usage examples for Windows
